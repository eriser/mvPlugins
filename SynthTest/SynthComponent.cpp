#include "JuceHeaders.h"
#include "SynthComponent.h"


#include <fstream>
#include <streambuf>

SynthAudioSource::SynthAudioSource(MidiKeyboardState& keyState)
    : keyboardState(keyState)
{
}

void SynthAudioSource::prepareToPlay(int /*samplesPerBlockExpected*/, double sampleRate)
{
    midiCollector.reset(sampleRate);
    synth.SetSampleRate(sampleRate);
}

void SynthAudioSource::releaseResources()
{
}

void SynthAudioSource::handleMidiEvent(const MidiMessage& m)
{
    const int channel = m.getChannel();
    const int noteOffset = -24;

    if (m.isNoteOn())
    {
        synth.PressKey(m.getNoteNumber() + noteOffset, m.getFloatVelocity(), 0.0);
    }
    else if (m.isNoteOff())
    {
        synth.ReleaseKey(m.getNoteNumber() + noteOffset);
    }
    else if (m.isAllNotesOff())
    {
        synth.ReleaseAll();
    }
    else if (m.isAllSoundOff())
    {
        synth.KillAll();
    }
}

void SynthAudioSource::render(AudioBuffer<float>* buffer, int startSample, int numSamples)
{
    float* left = buffer->getWritePointer(0);
    float* right = buffer->getWritePointer(1);
    float* ptrs[] = { left + startSample, right + startSample };
    synth.Synthesize(ptrs, numSamples);
}

void SynthAudioSource::getNextAudioBlock(const AudioSourceChannelInfo& bufferToFill)
{
    // the synth always adds its output to the audio buffer, so we have to clear it
    // first..
    bufferToFill.clearActiveBufferRegion();

    // fill a midi buffer with incoming messages from the midi input.
    MidiBuffer incomingMidi;
    midiCollector.removeNextBlockOfMessages(incomingMidi, bufferToFill.numSamples);

    // pass these messages to the keyboard state so that it can update the component
    // to show on-screen which keys are being pressed on the physical midi keyboard.
    // This call will also add midi messages to the buffer which were generated by
    // the mouse-clicking on the on-screen keyboard.
    keyboardState.processNextMidiBuffer(incomingMidi, 0, bufferToFill.numSamples, true);

    MidiBuffer::Iterator midiIterator(incomingMidi);
    midiIterator.setNextSamplePosition(0);

    int midiEventPos;
    MidiMessage m;

    // const ScopedLock sl(lock);

    int startSample = 0;
    int numSamples = bufferToFill.numSamples;
    while (numSamples > 0)
    {
        if (!midiIterator.getNextEvent(m, midiEventPos))
        {
            render(bufferToFill.buffer, startSample, numSamples);
            return;
        }

        const int samplesToNextMidiMessage = midiEventPos;

        if (samplesToNextMidiMessage >= numSamples)
        {
            render(bufferToFill.buffer, startSample, numSamples);
            handleMidiEvent(m);
            break;
        }

        if (samplesToNextMidiMessage < 64)
        {
            handleMidiEvent(m);
            continue;
        }

        render(bufferToFill.buffer, startSample, samplesToNextMidiMessage);
        handleMidiEvent(m);
        startSample += samplesToNextMidiMessage;
        numSamples -= samplesToNextMidiMessage;
    }

    while (midiIterator.getNextEvent(m, midiEventPos))
        handleMidiEvent(m);
}


// SynthComponent =================================================================================

SynthComponent::SynthComponent(AudioDeviceManager& audioDeviceManager)
    : deviceManager(audioDeviceManager)
    , synthAudioSource(keyboardState)
    , keyboardComponent(keyboardState, MidiKeyboardComponent::horizontalKeyboard)
    , fileChooser("File", File::nonexistent, false, false, false,
                  "*.yaml", String(),
                  "Choose a YAML preset file to open it in the editor")
{
    addAndMakeVisible(keyboardComponent);
    audioSourcePlayer.setSource(&synthAudioSource);
    deviceManager.addAudioCallback(&audioSourcePlayer);
    deviceManager.addMidiInputCallback(String::empty, &(synthAudioSource.midiCollector));

    // output box
    addAndMakeVisible(outputBox);
    outputBox.setReadOnly(true);
    outputBox.setMultiLine(true);
    outputBox.setFont(Font(Font::getDefaultMonospacedFontName(), 10.0f, Font::plain));

    // load init preset
    std::ifstream presetFile("../SynthPresets/init.yaml");
    std::string str((std::istreambuf_iterator<char>(presetFile)), std::istreambuf_iterator<char>());
    loadPreset(str);

    addAndMakeVisible(realoadButton = new TextButton("Reload", "Load preset form the editor"));
    realoadButton->addListener(this);

    // editor box
    addAndMakeVisible(editor = new CodeEditorComponent(codeDocument, &tokenizer));
    editor->loadContent(str);
    editor->setTabSize(4, true);

    setOpaque(true);
    setSize(640, 480);

    addAndMakeVisible(fileChooser);
    fileChooser.addListener(this);
}

SynthComponent::~SynthComponent()
{
    audioSourcePlayer.setSource(nullptr);
    deviceManager.removeMidiInputCallback(String::empty, &(synthAudioSource.midiCollector));
    deviceManager.removeAudioCallback(&audioSourcePlayer);
}

void SynthComponent::paint(Graphics& g)
{
    g.fillAll(Colours::white);
}

void SynthComponent::resized()
{
    Rectangle<int> rect(getLocalBounds());
    keyboardComponent.setBounds(rect.removeFromBottom(64));

    Rectangle<int> tempRect = rect.removeFromBottom(64);
    realoadButton->setBounds(tempRect.removeFromLeft(64).reduced(4));
    outputBox.setBounds(tempRect);

    fileChooser.setBounds(rect.removeFromTop(25));
    editor->setBounds(rect);
}

void SynthComponent::buttonClicked(Button* button)
{
    if (button == realoadButton)
    {
        std::string str = editor->getTextInRange(Range<int>(0, INT_MAX)).toStdString();

        loadPreset(str);
    }
}

void SynthComponent::loadPreset(const std::string& presetStr)
{
    synthAudioSource.synth.KillAll();

    std::string messages;
    if (synthAudioSource.synth.LoadConfig(presetStr, &messages))
        outputBox.setText("Preset loaded:\n" + messages);
    else
        outputBox.setText("Failed to load preset:\n" + messages);
}

void SynthComponent::filenameComponentChanged(FilenameComponent*)
{
    String str = fileChooser.getCurrentFile().loadFileAsString();
    editor->loadContent(str);
    loadPreset(str.toStdString());
}