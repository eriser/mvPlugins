#include "JuceHeaders.h"
#include "SynthAudioSource.h"
#include "SynthTextEditorComponent.h"
#include "SynthGUI.h"

SynthAudioSource::SynthAudioSource(MidiKeyboardState& keyState, mvSynth::Synth* synth)
    : keyboardState(keyState)
    , synth(synth)
{
}

void SynthAudioSource::prepareToPlay(int /*samplesPerBlockExpected*/, double sampleRate)
{
    midiCollector.reset(sampleRate);
    synth->SetSampleRate(sampleRate);
}

MidiMessageCollector* SynthAudioSource::getMidiCollector()
{
    return &midiCollector;
}

void SynthAudioSource::releaseResources()
{
}

void SynthAudioSource::handleMidiEvent(const MidiMessage& m)
{
    const int channel = m.getChannel();
    const int noteOffset = -24;

    // TODO: mod wheel, pitch wheel, etc.

    if (m.isNoteOn())
    {
        synth->PressKey(m.getNoteNumber() + noteOffset, m.getFloatVelocity(), 0.0);
    }
    else if (m.isNoteOff())
    {
        synth->ReleaseKey(m.getNoteNumber() + noteOffset);
    }
    else if (m.isAllNotesOff())
    {
        synth->ReleaseAll();
    }
    else if (m.isAllSoundOff())
    {
        synth->KillAll();
    }
}

void SynthAudioSource::render(AudioBuffer<float>* buffer, int startSample, int numSamples)
{
    float* left = buffer->getWritePointer(0);
    float* right = buffer->getWritePointer(1);
    float* ptrs[] = { left + startSample, right + startSample };
    synth->Synthesize(ptrs, numSamples);
}

void SynthAudioSource::getNextAudioBlock(const AudioSourceChannelInfo& bufferToFill)
{
    // the synth always adds its output to the audio buffer, so we have to clear it
    // first..
    bufferToFill.clearActiveBufferRegion();

    // fill a midi buffer with incoming messages from the midi input.
    MidiBuffer incomingMidi;
    midiCollector.removeNextBlockOfMessages(incomingMidi, bufferToFill.numSamples);

    // pass these messages to the keyboard state so that it can update the component
    // to show on-screen which keys are being pressed on the physical midi keyboard.
    // This call will also add midi messages to the buffer which were generated by
    // the mouse-clicking on the on-screen keyboard.
    keyboardState.processNextMidiBuffer(incomingMidi, 0, bufferToFill.numSamples, true);

    MidiBuffer::Iterator midiIterator(incomingMidi);
    midiIterator.setNextSamplePosition(0);

    int midiEventPos;
    MidiMessage m;

    // const ScopedLock sl(lock);

    int startSample = 0;
    int numSamples = bufferToFill.numSamples;
    while (numSamples > 0)
    {
        if (!midiIterator.getNextEvent(m, midiEventPos))
        {
            render(bufferToFill.buffer, startSample, numSamples);
            return;
        }

        const int samplesToNextMidiMessage = midiEventPos;

        if (samplesToNextMidiMessage >= numSamples)
        {
            render(bufferToFill.buffer, startSample, numSamples);
            handleMidiEvent(m);
            break;
        }

        if (samplesToNextMidiMessage < 64)
        {
            handleMidiEvent(m);
            continue;
        }

        render(bufferToFill.buffer, startSample, samplesToNextMidiMessage);
        handleMidiEvent(m);
        startSample += samplesToNextMidiMessage;
        numSamples -= samplesToNextMidiMessage;
    }

    while (midiIterator.getNextEvent(m, midiEventPos))
        handleMidiEvent(m);
}